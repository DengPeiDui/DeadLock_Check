介绍
====
之前看到的别人用GO语言写了一个死锁检测工具，大概看了一下的实现原理，然后自己就用JAVA写了一次。

原项目链接
https://github.com/funny/sync


作用
====
在开发调试期，帮助排查程序中的死锁情况。


原理
====
LockHolder保存了整个进程所有线程与锁之间的持有关系，每次上锁时，都判断一下这次上锁是否会造成死锁，死锁的话抛出异常，并打印相对应的信息。
死锁不一定发生在两个线程之间，有可能出现在多个线程之间交叉出现。


 |-线程A---争取---锁1

 |                  |
      ------属于-----
 |   |

 |  线程B---争取---锁2

 |                  |
      ------属于-----
 |   |

 |  线程C---争取---锁3

 |                  |
  ----------属于-----

所以，在检测死锁的时候，递归遍历每层锁与线程的关系，当检测到会形成回路（即发生死锁的时候）的时候，退出递归，报错。
看了一下原作者的实现，好像并不是用递归，等考完试有空再看看原作者是怎么实现检测多个线程之间的锁。


用法
====
例如，用ReentrantLock，正常开发的时候，我们可以用系统原生的。
	import com.deadlock.ReentrantLock;
但是测试的时候，只要把包改一下：
	import java.util.concurrent.locks.ReentrantLock;
就可以检测死锁。


优点
====
不用修改项目的运行代码，只需修改引用的包，即可检测死锁，并获得运行栈的信息。


实现
====
目前只实现了ReentrantLock这个类，不过其他类的实现原理也一样，实现的时候只需在lock前后注册一下信息，unlock后修改一下信息即可。


不足
====
没有实现tryLock()方法的检测，等考完试有空再实现。


